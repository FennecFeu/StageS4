(*
module Graph
  
  use int.Int
  use export set.Fset

  (* The type related to the edges of the graph *)
  type edge

  (* The type related to the vertices of the graph *)
  type vertex

  (* The set containing all the vertices of the graph *)
  constant vertices : fset vertex

  (* The set containing all the edges of the graph *)
  constant edges : fset edge
  
  (* Function to get all the successors of the vertex in the graph *)
  function successors vertex : fset vertex
  
  (* Function to get all the predecessors of the vertex in the graph *)
  function predecessors vertex : fset vertex
  
  (* The successors of a vertex in the graph are all vertices in the graph *)
  axiom successors_vertices:
    forall x. mem x vertices -> subset (successors x) vertices
    
  (* The predecessors of a vertex in the graph are all vertices in the graph *)
  axiom predecessors_vertices:
    forall x. mem x vertices -> subset (predecessors x) vertices
    
  (* Predecessors and successors are linked and consistent *)
  axiom equiv_preds_and_succs:
    forall x y. mem y (successors x) <-> mem x (predecessors y)
  
  (* Function to get an edge from the two nodes at its extremities *)
  function get_edge vertex vertex : edge
  
  (* Edges have vertices at their extremities that all belong to the graph *)
  axiom get_edge_edges:
    forall x y. mem (get_edge x y) edges -> mem x vertices /\ mem y vertices
    
  (* Edges imply a successor for a vertex in the graph *)
  axiom get_edge_succs:
    forall x y. mem (get_edge x y) edges -> mem y (successors x)
    
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) edges

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
  
  predicate (<<) (x y: vertex)
  
  constant min_vertex : vertex
  
  axiom vertex_min_vertex :
    mem min_vertex vertices
  
  axiom minimum_min_vertex :
    forall x. mem x vertices -> min_vertex << x
    
  (*
    @requires None
    @ensures Given the operation and a graph, returns from an entry a modified value after calling the operation on all the nodes of the graph.
   *)
  (* type ('a) fold_vertices = ('a -> vertex -> 'a) -> 'a -> 'a *)
  
  function incidence_number vertex : int
  
  axiom incidence_number_cardinal :
    forall x. mem x vertices -> incidence_number x = cardinal (successors x) + cardinal (predecessors x)
end *)

module Vertex

  (* The type related to the vertices of the graph *)
  type vertex

  clone export set.SetApp with type elt = vertex
  
  (* Predicate on vertex that belongs to the set or not *)
  predicate vertex_in (x: vertex) (s: fset vertex) = mem x s
end

module Edge

  use Vertex

  (* The type related to the elements in an edge *)
  type edge_elt
  (* The type related to the edges of the graph *)
  type edge = (vertex, edge_elt, vertex)
  
  (* Function to get an edge_elt from an edge *)
  let function get_edge_elt edge : edge_elt
  =
  
    let (_, elt, _) = edge in
    elt
  
  (* Function to get the first vertex from an edge *)
  let function get_edge_pred edge : edge_elt
  =
    let (pred, _, _) = edge in
    pred
    
  (* Function to get the first vertex from an edge *)
  let function get_edge_succ edge : edge_elt
  =
    let (_, _, succ) = edge in
    succ
  
  clone export set.SetApp with type elt = edge
  
end
  

module Graph
  
  use int.Int
  use Vertex
  use Edge
  
  clone export fmap.MapApp with type key = vertex
  
  (* The type of the successors and predecessors map in the graph *)
  type linked = t Vertex.set
  
  (* The type related to the graph *)
  type graph = {vertices : Vertex.set;
                preds : linked;
                succs : linked;
                edges : Edge.set; }
  invariant {forall v. Vertex.mem v vertices -> mem v preds} (*  *)
  invariant {forall v. Vertex.mem v vertices -> mem v succs}
  invariant {forall v. mem v preds -> subset (find v preds) vertices}
  invariant {forall v. mem v succs -> subset (find v succs) vertices}
  invariant {forall v w. Vertex.mem v vertices -> (vertex_in w (find v succs) <-> vertex_in v (find w preds))}
  invariant {forall e. Edge.mem e edges -> let (pred, _, succ) = e in vertex_in succ (find pred succs)}
  by {vertices = Vertex.empty(); preds = create(); succs = create(); edges = empty()}

  (*
  (* The set containing all the vertices of the data graph *)
  constant atoms : Vertex.set
  (* The set containing all the vertices of the query graph *)
  constant nodes : Vertex.set
  
  (* Nodes and atoms are two separate sets *)
  axiom inter_set_vertex_empty:
    disjoint atoms nodes
    
  (* The set containing all the edges of the data graph *)
  constant bridges : Edge.set
  (* The set containing all the edges of the query graph *)
  constant links : Edge.set
  
  (* Bridges and links are two separate sets *)
  axiom inter_set_edge_empty:
    disjoint bridges links
    *)
  
  (* Function to get all the successors of the vertex in the graph *)
  let function successors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.succs}
  =
    find v g.succs
  
  (* Function to get all the predecessors of the vertex in the graph *)
  let function predecessors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.preds}
  =
    find v g.preds
    
  (*
  
  (* Function to get an edge from the two nodes at its extremities *)
  function get_edge vertex vertex : edge
  
  (* Edges have vertices at their extremities that all belong to their graph *)
  axiom get_edge_bridges:
    forall x y. mem (get_edge x y) bridges -> mem x atoms /\ mem y atoms
  axiom get_edge_links:
    forall x y. mem (get_edge x y) links -> mem x nodes /\ mem y nodes
    
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) (union bridges links)

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
    
  (* Edges imply a successor for a vertex in the graph *)
  axiom get_edge_succs:
    forall x y. edge_exists x y -> mem y (successors x)
  
  (* Order relation *)
  predicate (<<) (x y: vertex)
  (* The minimum of the order relation *)
  constant min_node : vertex
  
  (* The minimum has to be among the nodes *)
  axiom node_min_node :
    mem min_node nodes
  
  (* The minimum is lesser than all the nodes *)
  axiom minimum_min_node :
    forall x. mem x nodes -> min_node << x
  
  function incidence_number vertex : int
  
  axiom incidence_number_cardinal :
    forall x. mem x (union nodes atoms) -> incidence_number x = cardinal (successors x) + cardinal (predecessors x)
    
  (*
  let incidence2_number (n: vertex) : int
  =
    cardinal (successors n) + cardinal (predecessors n)
    *)
    
    *)
end
    
module Matching

  use Vertex
  use Edge
  use Graph

  (* In order to build result *)
  clone export fmap.MapApp with type key = vertex
  
  (* Elements in the result set *)
  type matching = t vertex
  
end

(*
    
module AlgoGraph
  use int.Int
  use Vertex
  use Edge
  use Graph
  use Matching
  
  clone export set.SetApp with type elt = matching
  
  (* Predicate to say two vertices are similar *)
  let function is_compatible_vertex (n a: vertex) : bool
    requires {vertex_in a atoms}
    requires {vertex_in n nodes}
    ensures  {result = (incidence_number n <= incidence_number a)}
  =
    (*(incidence_number n <= incidence_number a) && *)true (* Temporarily *)
  
  (* To associate a node and an atom in a matching with one element *)
  let function start_matching (n a: vertex) : matching
    requires {vertex_in a atoms}
    requires {vertex_in n nodes}
    (*
    ensures  {mem n result}
    ensures  {a = (find n result)}
    ensures  {size result = 1}
    *)
    ensures  {Matching.(==) result (Matching.add n a Matching.empty)}
  =
    Matching.add n a (create ())
  
  (* THE ALMIGHTY ALGORITM *)
  let find_matched_pattern () : set
  =
    if is_empty atoms then empty()
    else (let all_starts = empty() in
    (* assert {all_starts == map start_matching (filter atoms (is_compatible_vertex min_node))}; *)
    empty()
    )
end

*)