(*
module Graph
  
  use int.Int
  use export set.Fset

  (* The type related to the edges of the graph *)
  type edge

  (* The type related to the vertices of the graph *)
  type vertex

  (* The set containing all the vertices of the graph *)
  constant vertices : fset vertex

  (* The set containing all the edges of the graph *)
  constant edges : fset edge
  
  (* Function to get all the successors of the vertex in the graph *)
  function successors vertex : fset vertex
  
  (* Function to get all the predecessors of the vertex in the graph *)
  function predecessors vertex : fset vertex
  
  (* The successors of a vertex in the graph are all vertices in the graph *)
  axiom successors_vertices:
    forall x. mem x vertices -> subset (successors x) vertices
    
  (* The predecessors of a vertex in the graph are all vertices in the graph *)
  axiom predecessors_vertices:
    forall x. mem x vertices -> subset (predecessors x) vertices
    
  (* Predecessors and successors are linked and consistent *)
  axiom equiv_preds_and_succs:
    forall x y. mem y (successors x) <-> mem x (predecessors y)
  
  (* Function to get an edge from the two nodes at its extremities *)
  function get_edge vertex vertex : edge
  
  (* Edges have vertices at their extremities that all belong to the graph *)
  axiom get_edge_edges:
    forall x y. mem (get_edge x y) edges -> mem x vertices /\ mem y vertices
    
  (* Edges imply a successor for a vertex in the graph *)
  axiom get_edge_succs:
    forall x y. mem (get_edge x y) edges -> mem y (successors x)
    
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) edges

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
  
  predicate (<<) (x y: vertex)
  
  constant min_vertex : vertex
  
  axiom vertex_min_vertex :
    mem min_vertex vertices
  
  axiom minimum_min_vertex :
    forall x. mem x vertices -> min_vertex << x
    
  (*
    @requires None
    @ensures Given the operation and a graph, returns from an entry a modified value after calling the operation on all the nodes of the graph.
   *)
  (* type ('a) fold_vertices = ('a -> vertex -> 'a) -> 'a -> 'a *)
  
  function incidence_number vertex : int
  
  axiom incidence_number_cardinal :
    forall x. mem x vertices -> incidence_number x = cardinal (successors x) + cardinal (predecessors x)
end *)

module Vertex

  (* The type related to the vertices of the graph *)
  type vertex

  clone export set.SetApp with type elt = vertex
  
  (* Predicate on vertex that belongs to the set or not *)
  let predicate vertex_in (x: vertex) (s: set) 
  ensures {result = mem x s}
  =
    mem x s
  
  (* Predicate to verify equality between two vertices *)
  let predicate vertex_eq (x y: vertex)
  ensures {result = (x = y)}
  =
    (singleton x) == (singleton y)
end

module Edge

  use Vertex

  (* The type related to the elements in an edge *)
  type edge_elt
  (* The type related to the edges of the graph *)
  type edge = (vertex, edge_elt, vertex)
  
  (* Function to get an edge_elt from an edge *)
  let function get_edge_elt edge : edge_elt
  =
  
    let (_, elt, _) = edge in
    elt
  
  (* Function to get the first vertex from an edge *)
  let function get_edge_pred edge : vertex
  =
    let (pred, _, _) = edge in
    pred
    
  (* Function to get the first vertex from an edge *)
  let function get_edge_succ edge : vertex
  =
    let (_, _, succ) = edge in
    succ
    
  (* Predicate to determine if two vertices can be the extremities of an edge *)
  let predicate correct_extremities (u v: vertex) (e: edge) : bool
  ensures {result = ((get_edge_pred e = u) /\ (get_edge_succ e = v))}
  =
    (vertex_eq (get_edge_pred e) u) && (vertex_eq (get_edge_succ e) v)
  
  clone export set.SetApp with type elt = edge
    
  (* Predicate to determine if the edge belongs to the given set *)
  let predicate edge_in (e: edge) (s: set)
  ensures {result = mem e s}
  =
    mem e s
  
  predicate has_edge_set (u v: vertex) (s: set) =
    exists e: edge. mem e s /\ correct_extremities u v e
  
end
  

module Graph
  
  use int.Int
  use Vertex
  use Edge
  
  clone export fmap.MapApp with type key = vertex
  
  (* The type of the successors and predecessors map in the graph *)
  type linked = t Vertex.set
  
  (* The type related to the graph *)
  type graph = {vertices : Vertex.set;
                preds : linked;
                succs : linked;
                edges : Edge.set; }
  (* All vertices are keys in preds *)
  invariant {forall v. Vertex.mem v vertices -> mem v preds}
  (* All vertices are keys in succs *)
  invariant {forall v. Vertex.mem v vertices -> mem v succs}
  (* Predecessors are vertices *)
  invariant {forall v. mem v preds -> subset (find v preds) vertices}
  (* Successors are vertices *)
  invariant {forall v. mem v succs -> subset (find v succs) vertices}
  (* Relation between predecessors and successors *)
  invariant {forall v w. Vertex.mem v vertices -> (vertex_in w (find v succs) <-> vertex_in v (find w preds))}
  (* A graph can't have two edges with same extremities *)
  invariant {forall e f: edge. (Edge.mem e edges /\ Edge.mem f edges)
            -> e = f \/ not get_edge_pred e = get_edge_pred f \/ not get_edge_succ e = get_edge_succ f}
  (* An edge means one vertex is the successor of the other edge *)
  invariant {forall e: edge. 
            let pred = get_edge_pred e in
            let succ = get_edge_succ e in
            (Edge.mem e edges -> vertex_in succ (find pred succs))}
  (* If a vertex has a successor, then there is an edge between those two vertices *)
  invariant {forall u v: vertex. Vertex.mem u vertices /\ vertex_in v (find u succs) -> has_edge_set u v edges}
  by {vertices = Vertex.empty(); preds = create(); succs = create(); edges = empty()}
  
  (* Function to get all the successors of the vertex in the graph *)
  let function successors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.succs}
  =
    find v g.succs
  
  (* Function to get all the predecessors of the vertex in the graph *)
  let function predecessors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.preds}
  =
    find v g.preds
    
  let predicate has_edge_graph (u v: vertex) (g: graph) : bool
  requires {vertex_in u g.vertices}
  ensures {result = vertex_in v (successors u g)}
  =
    (vertex_in v (successors u g))
    
  lemma eq_has_edge:
    forall g: graph. forall u v: vertex.
    vertex_in u g.vertices -> (has_edge_graph u v g <-> has_edge_set u v g.edges)
  
  (* Function to get an edge from the two nodes at its extremities *)
  let function find_edge (u v: vertex) (g: graph) : edge
  requires {vertex_in u g.vertices}
  requires {has_edge_graph u v g}
  ensures  {Edge.mem result g.edges}
  ensures  {correct_extremities u v result}
  =
    (* Auxiliary function to choose an edge and verify if the edge is valid or not *)
    let rec compare_edge (s: Edge.set) : edge
    variant  {cardinal s}
    requires {Edge.subset s g.edges}
    requires {has_edge_set u v s}
    ensures  {Edge.mem result g.edges}
    ensures  {correct_extremities u v result}
    =
    let e = choose s in
    let new_set = Edge.remove e s in
    if correct_extremities u v e then e
    else compare_edge new_set
    in
    compare_edge g.edges
    
  (*
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) (union bridges links)

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
  *)
  
  (* Function to obtain the number of predecessors and successors of the vertex in the graph *)
  let function incidence_number (v: vertex) (g: graph) : int
  requires {vertex_in v g.vertices}
  ensures  {result = cardinal (find v g.succs) + cardinal (find v g.preds)}
  =
    cardinal (find v g.succs) + cardinal (find v g.preds)
    
  (* Predicate that establish an order between the vertices in a graph *)
  let predicate order (x y: vertex) (g: graph) : bool
  requires {vertex_in x g.vertices}
  requires {vertex_in y g.vertices}
  ensures  {result = (incidence_number x g >= incidence_number y g)}
  =
    incidence_number x g >= incidence_number y g
  
  (* The order must be reflexive *)
  lemma order_reflexivity:
    forall g: graph. forall x: vertex. Vertex.mem x g.vertices -> order x x g
    
  (* The order must be transitive *)
  lemma order_transitivity:
    forall g: graph. forall x y z: vertex.
    Vertex.mem x g.vertices /\ Vertex.mem y g.vertices /\ Vertex.mem z g.vertices
    /\ order x y g /\ order y z g -> order x z g
    
  (* Function to obtain the optimum vertex in a graph (it will be exploited to start our algorithm) *)
  let function optimum_vertex (g: graph) : vertex
  requires {not Vertex.is_empty g.vertices}
  ensures  {vertex_in result g.vertices}
  ensures  {forall v: vertex. Vertex.mem v g.vertices -> order result v g}
  =
    (* Auxiliary function in order to make the recursion to verify the vertex we stock is the optimum *)
    let rec compare_optimum (x: vertex) (s: Vertex.set) : vertex
    variant  {cardinal s} (* We remove vertices from the set possible candidate to be the optimum *)
    requires {Vertex.mem x g.vertices}
    requires {Vertex.subset s g.vertices} 
    requires {forall v: vertex. Vertex.mem v (Vertex.diff g.vertices s) -> order x v g} (* x is the local optimum *)
    ensures  {vertex_in result g.vertices}
    ensures  {forall v: vertex. Vertex.mem v g.vertices -> order result v g}
    =
      if is_empty s then x
      else let y = Vertex.choose s in
      let new_set = Vertex.remove y s in
      if order x y g then compare_optimum x new_set
      else let _ = assert {order y x g} in
      compare_optimum y new_set
    in
    let x = Vertex.choose g.vertices in
    let s = Vertex.remove x g.vertices in
    compare_optimum x s
      
  
end
    
module Matching

  use Vertex
  use Edge
  use Graph

  (* In order to build result *)
  clone export fmap.MapApp with type key = vertex
  
  (* Elements in the result set *)
  type matching = t vertex
  
end

module States

  use Vertex
  use Edge
  use Graph
  use Matching
  
  (* State to register the step in the algorithm on the query graph *)
  type qstate =
    {n_seen : Vertex.set;
     n_seen_succ : Vertex.set;
     n_seen_pred : Vertex.set;}
  invariant {Vertex.is_empty (Vertex.inter n_seen n_seen_succ)}
  invariant {Vertex.is_empty (Vertex.inter n_seen n_seen_pred)}
  by {n_seen = Vertex.empty(); n_seen_pred = Vertex.empty(); n_seen_succ = Vertex.empty()}
     
  (* Function to create an empty qstate *)
  let function empty_qstate () : qstate
  ensures {Vertex.is_empty result.n_seen}
  ensures {Vertex.is_empty result.n_seen_succ}
  ensures {Vertex.is_empty result.n_seen_pred}
  =
    {n_seen = Vertex.empty();
     n_seen_succ = Vertex.empty();
     n_seen_pred = Vertex.empty();}
  
  (* State to register the step in the algorithm on the data graph *)
  type gstate =
    {matching_peers : Matching.matching;
     a_seen : Vertex.set;
     a_seen_succ : Vertex.set;
     a_seen_pred : Vertex.set;
     a_next : Vertex.set;}
  invariant {forall a: vertex. Vertex.mem a a_seen <-> exists n: vertex. Matching.mapsto n a matching_peers}
  invariant {Vertex.is_empty (Vertex.inter a_seen a_seen_succ)}
  invariant {Vertex.is_empty (Vertex.inter a_seen a_seen_pred)}
  by {matching_peers = create(); a_seen = Vertex.empty(); a_seen_pred = Vertex.empty(); a_seen_succ = Vertex.empty(); a_next = Vertex.empty()}
  
  (* Function to create an empty gstate *)
  let function empty_gstate () : gstate
  ensures {Matching.is_empty result.matching_peers}
  ensures {Vertex.is_empty result.a_seen}
  ensures {Vertex.is_empty result.a_seen_succ}
  ensures {Vertex.is_empty result.a_seen_pred}
  ensures {Vertex.is_empty result.a_next}
  =
    {matching_peers = Matching.create();
     a_seen = Vertex.empty();
     a_seen_succ = Vertex.empty();
     a_seen_pred = Vertex.empty();
     a_next = Vertex.empty();}
     
  (* Function to add a peering in the g_state, and make the needed modification *)
  let function add_peering_g (g: graph) (n a: vertex) (s: gstate) : gstate
  requires {vertex_in a g.vertices}
  requires {not Matching.mem n s.matching_peers}
  requires {forall v: vertex. not Matching.mapsto v a s.matching_peers}
  ensures  {result.a_seen = Vertex.add a s.a_seen}
  ensures  {result.matching_peers = Matching.add n a s.matching_peers}
  ensures  {result.a_seen_succ = Vertex.diff (Vertex.union s.a_seen_succ (successors a g)) (result.a_seen)}
  ensures  {result.a_seen_pred = Vertex.diff (Vertex.union s.a_seen_pred (predecessors a g)) (result.a_seen)}
  ensures  {result.a_next = Vertex.union (successors a g) (predecessors a g)}
  =
    let new_a_seen = Vertex.add a s.a_seen in
    {matching_peers = Matching.add n a s.matching_peers;
     a_seen = new_a_seen;
     a_seen_succ = Vertex.diff (Vertex.union s.a_seen_succ (successors a g)) (new_a_seen);
     a_seen_pred = Vertex.diff (Vertex.union s.a_seen_pred (predecessors a g)) (new_a_seen);
     a_next = Vertex.union (successors a g) (predecessors a g);}
     
  (* Function to add the vertex n in the q_state, and make the needed modification *)
  let function add_peering_q (q: graph) (n: vertex) (s: qstate) : qstate
  requires {vertex_in n q.vertices}
  ensures  {result.n_seen = Vertex.add n s.n_seen}
  ensures  {result.n_seen_succ = Vertex.diff (Vertex.union s.n_seen_succ (successors n q)) (result.n_seen)}
  ensures  {result.n_seen_pred = Vertex.diff (Vertex.union s.n_seen_pred (predecessors n q)) (result.n_seen)}
  =
    let new_n_seen = Vertex.add n s.n_seen in
    {n_seen = new_n_seen;
     n_seen_succ = Vertex.diff (Vertex.union s.n_seen_succ (successors n q)) (new_n_seen);
     n_seen_pred = Vertex.diff (Vertex.union s.n_seen_pred (predecessors n q)) (new_n_seen);}
  
  clone export set.SetApp with type elt = gstate
  
  type gstates = set
  
end

module AlgoGraph
  use int.Int
  use Vertex
  use Edge
  use Graph
  use Matching
  
  clone export set.SetApp with type elt = matching
  
  (* Predicate to say two vertices are similar *)
  let function is_compatible_vertex (q g: graph) (n a: vertex) : bool
    requires {vertex_in a g.vertices}
    requires {vertex_in n q.vertices}
    ensures  {result = (incidence_number n q <= incidence_number a g)}
  =
    (incidence_number n q <= incidence_number a g) && true (* Temporarily *)
    
  (* Predicate to say two edges are similar *)
  let function is_compatible_edge (l b: edge) (q g: graph) : bool
    requires {edge_in b q.edges}
    requires {edge_in l g.edges}
    ensures  {true}
  =
    true
  
  (* Function to associate a node and an atom in a matching with one element *)
  let function start_matching (q g: graph) (n a: vertex) : matching
    requires {vertex_in a g.vertices}
    requires {vertex_in n q.vertices}
    ensures  {Matching.(==) result (Matching.add n a Matching.empty)}
  =
    Matching.add n a (create ())
    
  (* Function to create the set all_starts in the main algorithm *)
  let function create_all_starts (q g: graph) : set
  requires {not Vertex.is_empty q.vertices}
  ensures  {let opt = optimum_vertex q in
            result == map (start_matching q g opt) (filter g.vertices (is_compatible_vertex q g opt))}
  =
    let opt = optimum_vertex q in
    let rec create_rec (vertices: Vertex.set) (partial_starts: set) : set
    variant  {Vertex.cardinal vertices}
    requires {Vertex.subset vertices g.vertices}
    requires {partial_starts == map (start_matching q g opt) (filter (Vertex.diff g.vertices vertices) (is_compatible_vertex q g opt))}
    ensures  {result == map (start_matching q g opt) (filter g.vertices (is_compatible_vertex q g opt))}
    =
      if Vertex.is_empty vertices then partial_starts
      else let a = Vertex.choose vertices in
      let new_set = Vertex.remove a vertices in
      let new_starts = if is_compatible_vertex q g opt a then add (start_matching q g opt a) partial_starts
                       else partial_starts in
      create_rec new_set new_starts
    in
    create_rec g.vertices (empty())
    
    
  (* THE ALMIGHTY ALGORITM *)
  let find_matched_pattern (q g: graph) : set
  (*
  (* Vertices in the matching are vertices of the graphs *)
  ensures {forall a n: vertex. forall m: matching. Matching.mem m result /\ Matching.mapsto n a m -> Vertex.mem n q.vertices /\ Vertex.mem a g.vertices}
  (* All vertices in the query graph are matched *)
  ensures {forall n: vertex. forall m: matching. Matching.mem m result /\Â Vertex.mem n q.vertices -> Matching.mem n m}
  (* The matching is bijective *)
  ensures {forall a a' n n': vertex. Matching.mapsto n a /\ Matching.mapsto n' a' -> (a = a' /\ n = n') \/ (a <> a' /\ n <> n')}
  (* Two matched vertices are similar *)
  ensures {forall a n: vertex. Matching.mapsto n a result -> is_similar_vertex n a}
  (* All edges in the query graph are matched in the data graph *)
  ensures {forall e: edge. Edge.mem e q.edges
          -> has_edge_graph (find (get_edge_pred e) result) (find (get_edge_succ e) result) g}
  (* Matched edges are similar *)
  ensures {forall e: edge. Edge.mem e q.edges
          -> let e' = find_edge (find (get_edge_pred e) result) (find (get_edge_succ e) result) g in
          is_similar_edge e e'}
          *)
  =
    if is_empty q.vertices then empty()
    else let all_starts = create_all_starts q g in
    empty()

end
