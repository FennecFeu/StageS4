module Vertex

  (* The type related to the vertices of the graph *)
  type vertex

  clone export set.SetApp with type elt = vertex
  
  (* Predicate on vertex that belongs to the set or not *)
  let predicate vertex_in (x: vertex) (s: set) 
  ensures {result = mem x s}
  =
    mem x s
  
  (* Predicate to verify equality between two vertices *)
  let predicate vertex_eq (x y: vertex)
  ensures {result = (x = y)}
  =
    (singleton x) == (singleton y)
  
  predicate disjoint_vertices (s1 s2: set) =
    is_empty (inter s1 s2)
    
  predicate is_union_vertices_without (s s1 s2 sw: set) =
    s = diff (union s1 s2) sw
  
end

module Edge

  use Vertex

  (* The type related to the elements in an edge *)
  type edge_elt
  (* The type related to the edges of the graph *)
  type edge = (vertex, edge_elt, vertex)
  
  (* Function to get an edge_elt from an edge *)
  let function get_edge_elt edge : edge_elt
  =
  
    let (_, elt, _) = edge in
    elt
  
  (* Function to get the first vertex from an edge *)
  let function get_edge_pred edge : vertex
  =
    let (pred, _, _) = edge in
    pred
    
  (* Function to get the first vertex from an edge *)
  let function get_edge_succ edge : vertex
  =
    let (_, _, succ) = edge in
    succ
    
  (* Predicate to determine if two vertices can be the extremities of an edge *)
  let predicate correct_extremities (u v: vertex) (e: edge) : bool
  ensures {result = ((get_edge_pred e = u) /\ (get_edge_succ e = v))}
  =
    (vertex_eq (get_edge_pred e) u) && (vertex_eq (get_edge_succ e) v)
    
  (* Predicate to determine if two vertices has at least one different extremity *)
  predicate distinct_extremities (e f: edge) =
    not get_edge_pred e = get_edge_pred f \/ not get_edge_succ e = get_edge_succ f
  
  clone export set.SetApp with type elt = edge
    
  (* Predicate to determine if the edge belongs to the given set *)
  let predicate edge_in (e: edge) (s: set)
  ensures {result = mem e s}
  =
    mem e s
  
  (* Predicate to determine if a set has an edge with correct extremities *)
  predicate has_edge_set (u v: vertex) (s: set) =
    exists e: edge. edge_in e s /\ correct_extremities u v e
    
  (* Predicate to determine if a set has only one edge with the same extremities *)  
  predicate extremities_primary_key (s: set) =
    forall e f: edge. (edge_in e s /\ edge_in f s) -> e = f \/ distinct_extremities e f
  
end
  

module Graph
  
  use int.Int
  use Vertex
  use Edge
  
  clone export fmap.MapApp with type key = vertex
  
  (* The type of the successors and predecessors map in the graph *)
  type linked = t Vertex.set
  
  (* Predicate to say a set of vertices is the domain of a map *)
  predicate vertices_is_domain (s: Vertex.set) (m: linked) =
    forall v. vertex_in v s <-> mem v m
    
  (* Predicate to say the values of the map are included in the set s *)
  predicate values_subset_of (m: linked) (s: Vertex.set) =
    forall v. mem v m -> subset (find v m) s
  
  (* Predicate to say that two maps acts like a mirror for two vertices *)
  predicate mirror_between_maps_two_vertices (v w: vertex) (m1 m2: linked) =
    vertex_in w (find v m1) <-> vertex_in v (find w m2)
  
  (* Predicate to say that two maps acts like a mirror for two vertices *)
  predicate mirror_between_maps (m1 m2: linked) =
    forall v w. mem v m1 -> mirror_between_maps_two_vertices v w m1 m2
  
  (* Predicate to determine if one of the element returned by the find is actually succ *)
  predicate find_vertex (pred succ: vertex) (m: linked) =
    vertex_in succ (find pred m)
    
  (* Predicate to link edge set and linked map *)
  predicate edge_means_link (s: Edge.set) (m: linked) =
    forall e: edge. (Edge.mem e s -> find_vertex (get_edge_pred e) (get_edge_succ e) m)
  
  predicate link_means_edge (m: linked) (s: Edge.set) =
    forall u v: vertex. mem u m /\ find_vertex u v m -> has_edge_set u v s
  
  (* The type related to the graph *)
  type graph = {vertices : Vertex.set;
                preds : linked;
                succs : linked;
                edges : Edge.set; }
  (* All vertices are keys in preds *)
  invariant {vertices_is_domain vertices preds}
  (* All vertices are keys in succs *)
  invariant {vertices_is_domain vertices succs}
  (* Predecessors are vertices *)
  invariant {values_subset_of preds vertices}
  (* Successors are vertices *)
  invariant {values_subset_of succs vertices}
  (* Relation between predecessors and successors *)
  invariant {mirror_between_maps preds succs}
  (* A graph can't have two edges with same extremities *)
  invariant {extremities_primary_key edges}
  (* An edge means one vertex is the successor of the other edge *)
  invariant {edge_means_link edges succs}
  (* If a vertex has a successor, then there is an edge between those two vertices *)
  invariant {link_means_edge succs edges}
  by {vertices = Vertex.empty(); preds = create(); succs = create(); edges = empty()}
  
  (* Function to get all the successors of the vertex in the graph *)
  let function successors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.succs}
  =
    find v g.succs
  
  (* Function to get all the predecessors of the vertex in the graph *)
  let function predecessors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.preds}
  =
    find v g.preds
    
  let predicate has_edge_graph (u v: vertex) (g: graph) : bool
  requires {vertex_in u g.vertices}
  ensures {result = find_vertex u v g.succs}
  =
    (vertex_in v (successors u g))
    
  lemma eq_has_edge:
    forall g: graph. forall u v: vertex.
    vertex_in u g.vertices -> (has_edge_graph u v g <-> has_edge_set u v g.edges)
  
  (* Function to get an edge from the two nodes at its extremities *)
  let function find_edge (u v: vertex) (g: graph) : edge
  requires {vertex_in u g.vertices}
  requires {has_edge_graph u v g}
  ensures  {Edge.mem result g.edges}
  ensures  {correct_extremities u v result}
  =
    (* Auxiliary function to choose an edge and verify if the edge is valid or not *)
    let rec compare_edge (s: Edge.set) : edge
    variant  {cardinal s}
    requires {Edge.subset s g.edges}
    requires {has_edge_set u v s}
    ensures  {Edge.mem result g.edges}
    ensures  {correct_extremities u v result}
    =
    let e = choose s in
    let new_set = Edge.remove e s in
    if correct_extremities u v e then e
    else compare_edge new_set
    in
    compare_edge g.edges
    
  (*
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) (union bridges links)

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
  *)
  
  (* Function to obtain the number of predecessors and successors of the vertex in the graph *)
  let function incidence_number (v: vertex) (g: graph) : int
  requires {vertex_in v g.vertices}
  ensures  {result = cardinal (find v g.succs) + cardinal (find v g.preds)}
  =
    cardinal (find v g.succs) + cardinal (find v g.preds)
    
  (* Predicate that establish an order between the vertices in a graph *)
  let predicate order (x y: vertex) (g: graph) : bool
  requires {vertex_in x g.vertices}
  requires {vertex_in y g.vertices}
  ensures  {result = (incidence_number x g >= incidence_number y g)}
  =
    incidence_number x g >= incidence_number y g
  
  (* The order must be reflexive *)
  lemma order_reflexivity:
    forall g: graph. forall x: vertex. Vertex.mem x g.vertices -> order x x g
    
  (* The order must be transitive *)
  lemma order_transitivity:
    forall g: graph. forall x y z: vertex.
    vertex_in x g.vertices /\ vertex_in y g.vertices /\ vertex_in z g.vertices
    /\ order x y g /\ order y z g -> order x z g
  
  (* Predicate to determine if the given vertex is a local optimum *)
  predicate is_local_optimum (opt: vertex) (g: graph) (s: Vertex.fset vertex) =
    forall v: vertex. Vertex.mem v s -> order opt v g
  
  (* Predicate to determine if the given vertex is an optimum *)
  predicate is_optimum (opt: vertex) (g: graph) =
    is_local_optimum opt g g.vertices
    
  (* Function to obtain the optimum vertex in a graph (it will be exploited to start our algorithm) *)
  let function optimum_vertex (g: graph) : vertex
  requires {not Vertex.is_empty g.vertices}
  ensures  {vertex_in result g.vertices}
  ensures  {is_optimum result g}
  =
    (* Auxiliary function in order to make the recursion to verify the vertex we stock is the optimum *)
    let rec compare_optimum (x: vertex) (s: Vertex.set) : vertex
    variant  {cardinal s} (* We remove vertices from the set possible candidate to be the optimum *)
    requires {vertex_in x g.vertices}
    requires {Vertex.subset s g.vertices} 
    requires {is_local_optimum x g (Vertex.diff g.vertices s)} (* x is the local optimum *)
    ensures  {vertex_in result g.vertices}
    ensures  {is_optimum result g}
    =
      if is_empty s then x
      else let y = Vertex.choose s in
      let new_set = Vertex.remove y s in
      if order x y g then compare_optimum x new_set
      else let _ = assert {order y x g} in
      compare_optimum y new_set
    in
    let x = Vertex.choose g.vertices in
    let s = Vertex.remove x g.vertices in
    compare_optimum x s
      
  
end
    
module Matching

  use Vertex
  use Edge
  use Graph

  (* In order to build result *)
  clone export fmap.MapApp with type key = vertex
  
  (* Elements in the result set *)
  type matching = t vertex
  
  predicate is_value_in (a: vertex) (m: matching) =
    exists n: vertex. mapsto n a m
  
  predicate is_range (s: Vertex.set) (m: matching) =
    forall a: vertex. vertex_in a s <-> is_value_in a m
  
end

module States

  use Vertex
  use Edge
  use Graph
  use Matching
  
  (* State to register the step in the algorithm on the query graph *)
  type qstate =
    {n_seen : Vertex.set;
     n_seen_succ : Vertex.set;
     n_seen_pred : Vertex.set;}
  invariant {disjoint_vertices n_seen n_seen_succ}
  invariant {disjoint_vertices n_seen n_seen_pred}
  by {n_seen = Vertex.empty(); n_seen_pred = Vertex.empty(); n_seen_succ = Vertex.empty()}
     
  (* Function to create an empty qstate *)
  let function empty_qstate () : qstate
  ensures {Vertex.is_empty result.n_seen}
  ensures {Vertex.is_empty result.n_seen_succ}
  ensures {Vertex.is_empty result.n_seen_pred}
  =
    {n_seen = Vertex.empty();
     n_seen_succ = Vertex.empty();
     n_seen_pred = Vertex.empty();}
  
  (* State to register the step in the algorithm on the data graph *)
  type gstate =
    {matching_peers : Matching.matching;
     a_seen : Vertex.set;
     a_seen_succ : Vertex.set;
     a_seen_pred : Vertex.set;
     a_next : Vertex.set;}
  invariant {is_range a_seen matching_peers}
  invariant {disjoint_vertices a_seen a_seen_succ}
  invariant {disjoint_vertices a_seen a_seen_pred}
  by {matching_peers = create(); a_seen = Vertex.empty(); a_seen_pred = Vertex.empty(); a_seen_succ = Vertex.empty(); a_next = Vertex.empty()}
  
  (* Function to create an empty gstate *)
  let function empty_gstate () : gstate
  ensures {Matching.is_empty result.matching_peers}
  ensures {Vertex.is_empty result.a_seen}
  ensures {Vertex.is_empty result.a_seen_succ}
  ensures {Vertex.is_empty result.a_seen_pred}
  ensures {Vertex.is_empty result.a_next}
  =
    {matching_peers = Matching.create();
     a_seen = Vertex.empty();
     a_seen_succ = Vertex.empty();
     a_seen_pred = Vertex.empty();
     a_next = Vertex.empty();}
     
  (* Function to add a peering in the g_state, and make the needed modification *)
  let function add_peering_g (g: graph) (n a: vertex) (s: gstate) : gstate
  requires {vertex_in a g.vertices}
  requires {not Matching.mem n s.matching_peers}
  requires {forall n. not Matching.mapsto n a s.matching_peers}
  ensures  {result.a_seen = Vertex.add a s.a_seen}
  ensures  {result.matching_peers = Matching.add n a s.matching_peers}
  ensures  {is_union_vertices_without result.a_seen_succ s.a_seen_succ (successors a g) result.a_seen}
  ensures  {is_union_vertices_without result.a_seen_pred s.a_seen_pred (predecessors a g) result.a_seen}
  ensures  {result.a_next = Vertex.union (successors a g) (predecessors a g)}
  =
    let new_a_seen = Vertex.add a s.a_seen in
    let new_matching_peers = Matching.add n a s.matching_peers in
    let _ = assert {forall a1. vertex_in a1 new_a_seen
                    -> (vertex_in a1 s.a_seen /\ exists n1. Matching.mapsto n1 a1 (Matching.add n a s.matching_peers))
                    \/ (a1 = a /\ Matching.mapsto n a1 (Matching.add n a s.matching_peers))} in
    {matching_peers = Matching.add n a s.matching_peers;
     a_seen = new_a_seen;
     a_seen_succ = Vertex.diff (Vertex.union s.a_seen_succ (successors a g)) (new_a_seen);
     a_seen_pred = Vertex.diff (Vertex.union s.a_seen_pred (predecessors a g)) (new_a_seen);
     a_next = Vertex.union (successors a g) (predecessors a g);}
     
     
  (* Function to add the vertex n in the q_state, and make the needed modification *)
  let function add_peering_q (q: graph) (n: vertex) (s: qstate) : qstate
  requires {vertex_in n q.vertices}
  ensures  {result.n_seen = Vertex.add n s.n_seen}
  ensures  {is_union_vertices_without result.n_seen_succ s.n_seen_succ (successors n q) result.n_seen}
  ensures  {is_union_vertices_without result.n_seen_pred s.n_seen_pred (predecessors n q) result.n_seen}
  =
    let new_n_seen = Vertex.add n s.n_seen in
    {n_seen = new_n_seen;
     n_seen_succ = Vertex.diff (Vertex.union s.n_seen_succ (successors n q)) (new_n_seen);
     n_seen_pred = Vertex.diff (Vertex.union s.n_seen_pred (predecessors n q)) (new_n_seen);}
  
  clone export set.SetApp with type elt = gstate
  
  type gstates = set
  
end

module AlgoGraph
  use int.Int
  use Vertex
  use Edge
  use Graph
  use Matching
  
  clone export set.SetApp with type elt = matching
  
  (* Predicate to say two vertices are similar *)
  let function is_compatible_vertex (q g: graph) (n a: vertex) : bool
    requires {vertex_in a g.vertices}
    requires {vertex_in n q.vertices}
    ensures  {result = (incidence_number n q <= incidence_number a g)}
  =
    (incidence_number n q <= incidence_number a g) && true (* Temporarily *)
    
  (* Predicate to say two edges are similar *)
  let function is_compatible_edge (l b: edge) (q g: graph) : bool
    requires {edge_in b q.edges}
    requires {edge_in l g.edges}
    ensures  {true}
  =
    true
  
  (* Function to associate a node and an atom in a matching with one element *)
  let function start_matching (q g: graph) (n a: vertex) : matching
    requires {vertex_in a g.vertices}
    requires {vertex_in n q.vertices}
    ensures  {Matching.(==) result (Matching.add n a Matching.empty)}
  =
    Matching.add n a (create ())
  
  (* Predicate to determine if couples in ms are correct starting matching from s *)
  predicate is_partial_compatible_matching (ms: set) (q g: graph) (opt: vertex) (s: Vertex.fset vertex) =
    ms == map (start_matching q g opt) (filter s (is_compatible_vertex q g opt))
  
  (* Predicate to determine if couples in ms are correct starting matching from the graph g *)
  predicate is_complete_compatible_matching (ms: set) (q g: graph) (opt: vertex) =
    is_partial_compatible_matching ms q g opt g.vertices
      
  (* Function to create the set all_starts in the main algorithm *)
  let function create_all_starts (q g: graph) : set
  requires {not Vertex.is_empty q.vertices}
  ensures  {is_complete_compatible_matching result q g (optimum_vertex q)}
  =
    let opt = optimum_vertex q in
    let rec create_rec (vertices: Vertex.set) (partial_starts: set) : set
    variant  {Vertex.cardinal vertices}
    requires {Vertex.subset vertices g.vertices}
    requires {is_partial_compatible_matching partial_starts q g opt (Vertex.diff g.vertices vertices)}
    ensures  {is_complete_compatible_matching result q g opt}
    =
      if Vertex.is_empty vertices then partial_starts
      else let a = Vertex.choose vertices in
      let new_set = Vertex.remove a vertices in
      let new_starts = if is_compatible_vertex q g opt a then add (start_matching q g opt a) partial_starts
                       else partial_starts in
      create_rec new_set new_starts
    in
    create_rec g.vertices (empty())
  
  predicate is_similar_vertex (n a: vertex)
  
  predicate is_similar_edge (e f: edge)
  
  (* Predicate to determine if matched vertices in the matching are vertices from the graph *)
  predicate is_matched_vertices_in (m: matching) (q g: graph) =
    forall a n: vertex. Matching.mapsto n a m -> vertex_in n q.vertices /\ vertex_in a g.vertices
  
  (* Predicate to determine if all vertices in the query graph are matched in m *)
  predicate is_matched_query_vertices (m: matching) (q: graph) =
    forall n: vertex. vertex_in n q.vertices -> Matching.mem n m
  
  (* Predicate to determine if the matching is bijective *)
  predicate is_bijective (m: matching) =
    forall a a' n n': vertex. Matching.mapsto n a m /\ Matching.mapsto n' a' m
    -> (a = a' /\ n = n') \/ (a <> a' /\ n <> n')
  
  (* Predicate to determine if in a matching, two matched vertices are similar *)
  predicate is_matched_vertices_similar (m: matching) =
    forall a n: vertex. Matching.mapsto n a m -> is_similar_vertex n a
  
  (* Predicate to determine if all edges in the query graph are matched in m *)
  predicate is_matched_query_edges (m: matching) (q g: graph) =
    forall e: edge. Edge.mem e q.edges
    -> has_edge_graph (find (get_edge_pred e) m) (find (get_edge_succ e) m) g
  
  (* Predicate to determine if in a matching, two matched edges are similar *)
  predicate is_matched_edges_similar (m: matching) (q g: graph) =
    forall e: edge. Edge.mem e q.edges
    -> let e' = find_edge (find (get_edge_pred e) m) (find (get_edge_succ e) m) g in
    is_similar_edge e e'
    
  (* Predicate to determine if a matching is a valid subgraph isomorphism *)
  predicate is_valid_matching (m: matching) (q g: graph) =
    is_matched_vertices_in m q g
    /\ is_matched_query_vertices m q
    /\ is_bijective m
    /\ is_matched_vertices_similar m
    /\ is_matched_query_edges m q g
    /\ is_matched_edges_similar m q g
  
  (* Predicate to determine if all matching in a set are valid *)
  predicate is_valid_result (r: set) (q g: graph) =
    forall m: matching. mem m r -> is_valid_matching m q g
  
  (* Predicate to determine if all valid matching are in the result set *)
  predicate is_all_valid_result (r: set) (q g: graph) =
    forall m: matching. is_valid_matching m q g -> mem m r
    
  (* THE ALMIGHTY ALGORITM *)
  let find_matched_pattern (q g: graph) : set
  =
    if is_empty q.vertices then empty()
    else let all_starts = create_all_starts q g in
    empty()

end
