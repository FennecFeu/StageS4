(*
module Graph
  
  use int.Int
  use export set.Fset

  (* The type related to the edges of the graph *)
  type edge

  (* The type related to the vertices of the graph *)
  type vertex

  (* The set containing all the vertices of the graph *)
  constant vertices : fset vertex

  (* The set containing all the edges of the graph *)
  constant edges : fset edge
  
  (* Function to get all the successors of the vertex in the graph *)
  function successors vertex : fset vertex
  
  (* Function to get all the predecessors of the vertex in the graph *)
  function predecessors vertex : fset vertex
  
  (* The successors of a vertex in the graph are all vertices in the graph *)
  axiom successors_vertices:
    forall x. mem x vertices -> subset (successors x) vertices
    
  (* The predecessors of a vertex in the graph are all vertices in the graph *)
  axiom predecessors_vertices:
    forall x. mem x vertices -> subset (predecessors x) vertices
    
  (* Predecessors and successors are linked and consistent *)
  axiom equiv_preds_and_succs:
    forall x y. mem y (successors x) <-> mem x (predecessors y)
  
  (* Function to get an edge from the two nodes at its extremities *)
  function get_edge vertex vertex : edge
  
  (* Edges have vertices at their extremities that all belong to the graph *)
  axiom get_edge_edges:
    forall x y. mem (get_edge x y) edges -> mem x vertices /\ mem y vertices
    
  (* Edges imply a successor for a vertex in the graph *)
  axiom get_edge_succs:
    forall x y. mem (get_edge x y) edges -> mem y (successors x)
    
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) edges

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
  
  predicate (<<) (x y: vertex)
  
  constant min_vertex : vertex
  
  axiom vertex_min_vertex :
    mem min_vertex vertices
  
  axiom minimum_min_vertex :
    forall x. mem x vertices -> min_vertex << x
    
  (*
    @requires None
    @ensures Given the operation and a graph, returns from an entry a modified value after calling the operation on all the nodes of the graph.
   *)
  (* type ('a) fold_vertices = ('a -> vertex -> 'a) -> 'a -> 'a *)
  
  function incidence_number vertex : int
  
  axiom incidence_number_cardinal :
    forall x. mem x vertices -> incidence_number x = cardinal (successors x) + cardinal (predecessors x)
end *)

module Vertex

  (* The type related to the vertices of the graph *)
  type vertex

  clone export set.SetApp with type elt = vertex
  
  (* Predicate on vertex that belongs to the set or not *)
  predicate vertex_in (x: vertex) (s: fset vertex) = mem x s
  
  (* Predicate to verify equality between two vertices *)
  let predicate vertex_eq (x y: vertex)
  ensures {result = (x = y)}
  =
    (singleton x) == (singleton y)
end

module Edge

  use Vertex

  (* The type related to the elements in an edge *)
  type edge_elt
  (* The type related to the edges of the graph *)
  type edge = (vertex, edge_elt, vertex)
  
  (* Function to get an edge_elt from an edge *)
  let function get_edge_elt edge : edge_elt
  =
  
    let (_, elt, _) = edge in
    elt
  
  (* Function to get the first vertex from an edge *)
  let function get_edge_pred edge : vertex
  =
    let (pred, _, _) = edge in
    pred
    
  (* Function to get the first vertex from an edge *)
  let function get_edge_succ edge : vertex
  =
    let (_, _, succ) = edge in
    succ
    
  (* Predicate to determine if two vertices can be the extremities of an edge *)
  let predicate correct_extremities (u v: vertex) (e: edge) : bool
  ensures {result = ((get_edge_pred e = u) /\ (get_edge_succ e = v))}
  =
    (vertex_eq (get_edge_pred e) u) && (vertex_eq (get_edge_succ e) v)
  
  clone export set.SetApp with type elt = edge
  
end
  

module Graph
  
  use int.Int
  use Vertex
  use Edge
  
  clone export fmap.MapApp with type key = vertex
  
  (* The type of the successors and predecessors map in the graph *)
  type linked = t Vertex.set
  
  (* The type related to the graph *)
  type graph = {vertices : Vertex.set;
                preds : linked;
                succs : linked;
                edges : Edge.set; }
  (* All vertices are keys in preds *)
  invariant {forall v. Vertex.mem v vertices -> mem v preds}
  (* All vertices are keys in succs *)
  invariant {forall v. Vertex.mem v vertices -> mem v succs}
  (* Predecessors are vertices *)
  invariant {forall v. mem v preds -> subset (find v preds) vertices}
  (* Successors are vertices *)
  invariant {forall v. mem v succs -> subset (find v succs) vertices}
  (* Relation between predecessors and successors *)
  invariant {forall v w. Vertex.mem v vertices -> (vertex_in w (find v succs) <-> vertex_in v (find w preds))}
  (*
  invariant {forall e f: edge. e = f \/ not get_edge_pred e = get_edge_pred f \/ not get_edge_succ e = get_edge_succ f}
  (* An edge means *)
  invariant {forall e: edge. let pred = get_edge_pred e in let succ = get_edge_succ e in (Edge.mem e edges <-> vertex_in succ (find pred succs))}
  *)
  by {vertices = Vertex.empty(); preds = create(); succs = create(); edges = empty()}
  
  (* Function to get all the successors of the vertex in the graph *)
  let function successors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.succs}
  =
    find v g.succs
  
  (* Function to get all the predecessors of the vertex in the graph *)
  let function predecessors (v: vertex) (g: graph) : Vertex.set
  requires {vertex_in v g.vertices}
  ensures  {result = find v g.preds}
  =
    find v g.preds
  
  (*
  (* Function to get an edge from the two nodes at its extremities *)
  let function get_edge (u v: vertex vertex) (g: graph) : edge
  requires {vertex_in u g.vertices}
  requires {vertex_in v (find u g.succs)}
  ensures  {Edge.mem result g.edges}
  ensures  {get_edge_succ result = v}
  ensures  {get_edge_pred result = u}
  =
    let rec *)
  
  
  (*
  (* Edges have vertices at their extremities that all belong to their graph *)
  axiom get_edge_bridges:
    forall x y. mem (get_edge x y) bridges -> mem x atoms /\ mem y atoms
  axiom get_edge_links:
    forall x y. mem (get_edge x y) links -> mem x nodes /\ mem y nodes
    
  (* Predicate to make the clone export *)
  predicate edge_exists (x y: vertex) = mem (get_edge x y) (union bridges links)

  clone export graph.Path with type vertex = vertex, predicate edge = edge_exists
    
  (* Edges imply a successor for a vertex in the graph *)
  axiom get_edge_succs:
    forall x y. edge_exists x y -> mem y (successors x)
  
  (* Order relation *)
  predicate (<<) (x y: vertex)
  (* The minimum of the order relation *)
  constant min_node : vertex
  
  (* The minimum has to be among the nodes *)
  axiom node_min_node :
    mem min_node nodes
  
  (* The minimum is lesser than all the nodes *)
  axiom minimum_min_node :
    forall x. mem x nodes -> min_node << x
  *)
  
  let function incidence_number (v: vertex) (g: graph) : int
  requires {vertex_in v g.vertices}
  ensures  {result = cardinal (find v g.succs) + cardinal (find v g.preds)}
  =
    cardinal (find v g.succs) + cardinal (find v g.preds)
    
  let predicate order (x y: vertex) (g: graph) : bool
  requires {vertex_in x g.vertices}
  requires {vertex_in y g.vertices}
  ensures  {result = (incidence_number x g >= incidence_number y g)}
  =
    incidence_number x g >= incidence_number y g
  
  lemma order_reflexivity:
    forall g: graph. forall x: vertex. Vertex.mem x g.vertices -> order x x g
    
  lemma order_transitivity:
    forall g: graph. forall x y z: vertex.
    Vertex.mem x g.vertices /\ Vertex.mem y g.vertices /\ Vertex.mem z g.vertices
    /\ order x y g /\ order y z g -> order x z g
    
  let optimum_vertex (g: graph) : vertex
  requires {not Vertex.is_empty g.vertices}
  ensures  {vertex_in result g.vertices}
  ensures  {forall v: vertex. Vertex.mem v g.vertices -> order result v g}
  =
    let rec compare_optimum (x: vertex) (ens: Vertex.set) : vertex
    variant  {cardinal ens}
    requires {vertex_in x g.vertices}
    requires {Vertex.subset ens g.vertices}
    ensures  {vertex_in result g.vertices}
    ensures  {forall v: vertex. Vertex.mem v ens -> order result v g}
    =
      if is_empty ens then x
      else let y = Vertex.choose ens in
      let new_ens = Vertex.remove y ens in
      if order x y g then compare_optimum x new_ens
      else compare_optimum y new_ens
    in
    let x = Vertex.choose g.vertices in
    let ens = Vertex.remove x g.vertices in
    compare_optimum x ens
      
  
end
    
module Matching

  use Vertex
  use Edge
  use Graph

  (* In order to build result *)
  clone export fmap.MapApp with type key = vertex
  
  (* Elements in the result set *)
  type matching = t vertex
  
end

(*
    
module AlgoGraph
  use int.Int
  use Vertex
  use Edge
  use Graph
  use Matching
  
  clone export set.SetApp with type elt = matching
  
  (* Predicate to say two vertices are similar *)
  let function is_compatible_vertex (n a: vertex) : bool
    requires {vertex_in a atoms}
    requires {vertex_in n nodes}
    ensures  {result = (incidence_number n <= incidence_number a)}
  =
    (*(incidence_number n <= incidence_number a) && *)true (* Temporarily *)
  
  (* To associate a node and an atom in a matching with one element *)
  let function start_matching (n a: vertex) : matching
    requires {vertex_in a atoms}
    requires {vertex_in n nodes}
    (*
    ensures  {mem n result}
    ensures  {a = (find n result)}
    ensures  {size result = 1}
    *)
    ensures  {Matching.(==) result (Matching.add n a Matching.empty)}
  =
    Matching.add n a (create ())
  
  (* THE ALMIGHTY ALGORITM *)
  let find_matched_pattern () : set
  =
    if is_empty atoms then empty()
    else (let all_starts = empty() in
    (* assert {all_starts == map start_matching (filter atoms (is_compatible_vertex min_node))}; *)
    empty()
    )
end

*)